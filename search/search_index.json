{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AVWX","text":"<p>AVWX is a global aviation weather fetching and parsing engine. It sources reports from a variety of government sources, parses individual elements, and calculates additional information like flight rules and time range interpolation.</p> <p>AVWX currently supports:</p> <ul> <li>Station data and search</li> <li>METAR</li> <li>TAF</li> <li>PIREP</li> <li>AIRMET / SIGMET</li> <li>NOTAM</li> <li>NBM (NBH, NBS, NBE)</li> <li>GFS (MAV, MEX)</li> </ul> <pre><code>&gt;&gt;&gt; import avwx\n&gt;&gt;&gt; jfk_metar = avwx.Metar('KJFK')\n&gt;&gt;&gt; jfk_metar.update()\nTrue\n&gt;&gt;&gt; jfk_metar.data.flight_rules\n'VFR'\n</code></pre> <p>These docs could use some love, and I am not a writer. You can help by making a pull request on GitHub</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Getting Started</li> </ul>"},{"location":"#aviation-reports","title":"Aviation Reports","text":"<ul> <li>METAR</li> <li>TAF</li> <li>PIREP</li> <li>AIRMET / SIGMET</li> <li>NOTAM</li> </ul>"},{"location":"#model-forecasts","title":"Model Forecasts","text":"<ul> <li>NBM NBH</li> <li>NBM NBS</li> <li>NBM NBE</li> <li>GFS MOS MAV</li> <li>GFS MOS MEX</li> </ul>"},{"location":"#utilities","title":"Utilities","text":"<ul> <li>Station</li> <li>Service</li> <li>Data Updates</li> <li>Other Data Structures</li> <li>Static Values</li> <li>Exceptions</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>AVWX is available on PyPI and requires Python 3.8 and above. Note: the package name is <code>avwx-engine</code>, but the import is <code>avwx</code></p> <pre><code>python -m pip install avwx-engine\n</code></pre> <p>Certain features may require additional libraries which most users won't need. For example, finding stations near a coordinate require scipy which is a large package. Attempting to run these methods without the necessary library will prompt you to install them. If you want to install all dependencies at once, run this instead:</p> <pre><code>python -m pip install avwx-engine[all]\n</code></pre>"},{"location":"getting-started/#tutorial","title":"Tutorial","text":"<p>Let's run through a quick example of fetching and parsing a METAR and TAF. There are other report types, but they follow the same basic API.</p> <pre><code>&gt;&gt;&gt; import avwx\n&gt;&gt;&gt; jfk_metar = avwx.Metar('KJFK')\n&gt;&gt;&gt; jfk_metar.update()\nTrue\n&gt;&gt;&gt; jfk_metar.raw\n'KJFK 281651Z 33021G25KT 10SM FEW060 M08/M23 A3054 RMK AO2 SLP339 T10831228'\n&gt;&gt;&gt; jfk_metar.data.flight_rules\n'VFR'\n&gt;&gt;&gt; jfk_metar.summary\n'Winds NNW-330 at 21kt gusting to 25kt, Vis 10sm, Temp -08C, Dew -23C, Alt 30.54inHg, Few clouds at 6000ft'\n&gt;&gt;&gt; jfk_metar.station.name\n'John F Kennedy International Airport'\n</code></pre> <p>Here, we create a METAR object and initialize it to pull data for JFK International airport. The update call fetches the current report, parses it into its individual components, and formats the translations. We then view the original report, the calculated flight rules, and a summary string from the translations. We can also see details of the station if available.</p> <pre><code>&gt;&gt;&gt; hnl_taf = avwx.Taf('PHNL')\n&gt;&gt;&gt; hnl_taf.update()\nTrue\n&gt;&gt;&gt; hnl_taf.raw\n'PHNL 312058Z 3121/0124 07012G19KT P6SM FEW030 SCT050 FM010500 06007KT P6SM FEW025 SCT045 FM012000 07012G19KT P6SM OVC030 SCT050'\n&gt;&gt;&gt; len(hnl_taf.data.forecast)\n3\n&gt;&gt;&gt; for line in hnl_taf.data.forecast:\n...   print(f\"{line.flight_rules} from {line.start_time.dt.strftime('%d-%H:%M')} to {line.end_time.dt.strftime('%d-%H:%M')}\")\n...\nVFR from 31-21:00 to 01-05:00\nVFR from 01-05:00 to 01-20:00\nMVFR from 01-20:00 to 01-24:00\n</code></pre> <p>Here we start of the same with the Taf object, this time for Honolulu. Because TAFs are forecasts, they contain multiple time periods. Here, we have three: a base and two amendments. Our code shows the different forecasted flight rules for each time period (day-hour). Taf objects have most of the same attributes as Metar objects, so we could also grab the station info if we needed to.</p>"},{"location":"av/airsigmet/","title":"AIRMET SIGMET","text":"<p>A SIGMET (Significant Meteorological Information) is a weather advisory for the safety of all aircraft. They are divided into:</p> <ul> <li>Convective - thunderstorms, hail, and cyclones</li> <li>Non-Convective - turbulence, icing, dust clouds, volcanic activity, and radiation</li> </ul> <p>An AIRMET (Airman's Meteorological Information) is a weather advisory for smaller aircraft or VFR navigation. They are divided into:</p> <ul> <li>Sierra - IFR conditions like low ceilings and mountain obscuration</li> <li>Tango - turbulence and high surface winds</li> <li>Zulu - icing and freezing levels</li> </ul> <p>Both types share a similar report format and therefore are combined into a single handling class. The <code>Bulletin</code> and weather type can be used to classify each as a SIGMET or AIRMET for filtering purposes.</p>"},{"location":"av/airsigmet/#class-avwxairsigmanager","title":"class avwx.AirSigManager()","text":"<p>Because of the global nature of these report types, we don't initialize a report class with a station ident like the other report types. Instead, we use a class to manage and update the list of all active SIGMET and AIRMET reports.</p> <pre><code>&gt;&gt;&gt; from avwx import AirSigManager\n&gt;&gt;&gt; from avwx.structs import Coord\n&gt;&gt;&gt; manager = AirSigManager()\n&gt;&gt;&gt; manager.update()\nTrue\n&gt;&gt;&gt; manager.last_updated\ndatetime.datetime(2022, 3, 27, 5, 54, 21, 516741, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; len(manager.reports)\n113\n&gt;&gt;&gt; len(manager.contains(Coord(lat=33.12, lon=-105)))\n5\n&gt;&gt;&gt; manager.reports[0].data.bulletin.type\nCode(repr='WA', value='airmet')\n&gt;&gt;&gt; manager.reports[0].data.type\n'AIRMET SIERRA FOR IFR AND MTN OBSCN'\n</code></pre>"},{"location":"av/airsigmet/#alongcoords-listavwxstructscoord-listavwxaigsigmet","title":"along(coords: List[avwx.structs.Coord]) -&gt; List[avwx.AigSigmet]","text":"<p>Returns available reports the intersect a flight path</p>"},{"location":"av/airsigmet/#async-async_update-bool","title":"async async_update() -&gt; bool","text":"<p>Async updates list of reports by fetching from all sources</p> <p>Returns <code>True</code> if new reports are available, else <code>False</code></p>"},{"location":"av/airsigmet/#containscoord-avwxstructscoord-listavwxaigsigmet","title":"contains(coord: avwx.structs.Coord) -&gt; List[avwx.AigSigmet]","text":"<p>Returns available reports that contain a coordinate</p>"},{"location":"av/airsigmet/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the reports were last updated</p>"},{"location":"av/airsigmet/#raw-liststr","title":"raw: List[str]","text":"<p>List of the original fetched report strings</p>"},{"location":"av/airsigmet/#reports-listavwxairsigmet-none","title":"reports: List[avwx.AirSigmet] = None","text":"<p>List of parsed <code>avwx.AirSigmet</code> objects</p>"},{"location":"av/airsigmet/#async-async_update-bool_1","title":"async async_update() -&gt; bool","text":"<p>Updates list of reports by fetching from all sources</p> <p>Returns <code>True</code> if new reports are available, else <code>False</code></p>"},{"location":"av/airsigmet/#class-avwxaigsigmet","title":"class avwx.AigSigmet()","text":"<p>In addition to the manager, you can use the <code>avwx.AirSigmet</code> class like any other report when you supply the report string via <code>parse</code> or <code>from_report</code>.</p> <pre><code>&gt;&gt;&gt; from avwx import AirSigmet\n&gt;&gt;&gt; report = 'WSPR31 SPJC 270529 SPIM SIGMET 3 VALID 270530/270830 SPJC- SPIM LIMA FIR EMBD TS OBS AT 0510Z NE OF LINE S0406 W07103 - S0358 W07225 - S0235 W07432 - S0114 W07503 TOP FL410 MOV SW NC='\n&gt;&gt;&gt; sigmet = AirSigmet.from_report(report)\nTrue\n&gt;&gt;&gt; sigmet.last_updated\ndatetime.datetime(2022, 3, 27, 6, 29, 33, 300935, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; sigmet.data.observation.coords\n[Coord(lat=-4.06, lon=-71.03, repr='S0406 W07103'),\n Coord(lat=-3.58, lon=-72.25, repr='S0358 W07225'),\n Coord(lat=-2.35, lon=-74.32, repr='S0235 W07432'),\n Coord(lat=-1.14, lon=-75.03, repr='S0114 W07503')]\n&gt;&gt;&gt; sigmet.data.observation.intensity\nCode(repr='NC', value='No change')\n&gt;&gt;&gt; sigmet.data.observation.ceiling\nNumber(repr='FL410', value=410, spoken='flight level four one zero')\n</code></pre>"},{"location":"av/airsigmet/#containscoord-avwxstructscoord-bool","title":"contains(coord: avwx.structs.Coord) -&gt; bool","text":"<p>Returns True if the report area contains a coordinate</p>"},{"location":"av/airsigmet/#data-avwxstructsairsigmetdata-none","title":"data: avwx.structs.AirSigmetData = None","text":"<p>AirSigmetData dataclass of parsed data values and units</p>"},{"location":"av/airsigmet/#from_reportreport-str-avwxaigsigmet","title":"from_report(report: str) -&gt; avwx.AigSigmet","text":"<p>Returns an updated report object based on an existing report</p>"},{"location":"av/airsigmet/#intersectspath-shapelygeometrylinestring-bool","title":"intersects(path: shapely.geometry.LineString) -&gt; bool","text":"<p>Returns True if the report area intersects a flight path</p>"},{"location":"av/airsigmet/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"av/airsigmet/#last_updated-datetimedatetime-none_1","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the report was last updated</p>"},{"location":"av/airsigmet/#parsereport-str-issued-optionaldate-none-bool","title":"parse(report: str, issued: Optional[date] = None) -&gt; bool","text":"<p>Updates report data by parsing a given report</p> <p>Can accept a report issue date if not a recent report string</p>"},{"location":"av/airsigmet/#raw-str-none","title":"raw: str = None","text":"<p>The unparsed report string</p>"},{"location":"av/airsigmet/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"av/airsigmet/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the report contents</p>"},{"location":"av/airsigmet/#class-avwxstructsairsigmetdata","title":"class avwx.structs.AirSigmetData","text":"<p>area: str</p> <p>body: str</p> <p>bulletin: avwx.structs.Bulletin</p> <p>correction: Optional[str]</p> <p>end_time: Optional[avwx.structs.Timestamp]</p> <p>forecast: Optional[avwx.structs.AirSigObservation]</p> <p>issuer: str</p> <p>observation: Optional[avwx.structs.AirSigObservation]</p> <p>raw: str</p> <p>region: str</p> <p>remarks: Optional[str]</p> <p>sanitized: str</p> <p>start_time: Optional[avwx.structs.Timestamp]</p> <p>station: Optional[str]</p> <p>time: Optional[avwx.structs.Timestamp]</p> <p>type: str</p>"},{"location":"av/airsigmet/#class-avwxstructsairsigmetobservation","title":"class avwx.structs.AirSigmetObservation","text":"<p>bounds: List[str]</p> <p>ceiling: Optional[avwx.structs.Number]</p> <p>coords: List[avwx.structs.Coord]</p> <p>end_time: Optional[avwx.structs.Timestamp]</p> <p>floor: Optional[avwx.structs.Number]</p> <p>intensity: Optional[avwx.structs.Code]</p> <p>movement: Optional[avwx.structs.Movement]</p> <p>other: List[str]</p> <p>poly: Optional[shapely.geometry.Polygon]</p> <p>position: Optional[avwx.structs.Coord]</p> <p>start_time: Optional[avwx.structs.Timestamp]</p> <p>type: Optional[avwx.structs.Code]</p>"},{"location":"av/metar/","title":"METAR","text":"<p>A METAR (Meteorological Aerodrome Report) is the surface weather observed at most controlled (and some uncontrolled) airports. They are updated once per hour or when conditions change enough to warrant an update, and the observations are valid for one hour after the report was issued or until the next report is issued.</p>"},{"location":"av/metar/#class-avwxmetarcode-str","title":"class avwx.Metar(code: str)","text":"<p>The Metar class offers an object-oriented approach to managing METAR data for a single station.</p> <p>Below is typical usage for fetching and pulling METAR data for KJFK.</p> <pre><code>&gt;&gt;&gt; from avwx import Metar\n&gt;&gt;&gt; kjfk = Metar(\"KJFK\")\n&gt;&gt;&gt; kjfk.station.name\n'John F Kennedy International Airport'\n&gt;&gt;&gt; kjfk.update()\nTrue\n&gt;&gt;&gt; kjfk.last_updated\ndatetime.datetime(2018, 3, 4, 23, 36, 6, 62376)\n&gt;&gt;&gt; kjfk.raw\n'KJFK 042251Z 32023G32KT 10SM BKN060 04/M08 A3008 RMK AO2 PK WND 32032/2251 SLP184 T00441078'\n&gt;&gt;&gt; kjfk.data.flight_rules\n'VFR'\n&gt;&gt;&gt; kjfk.translations.remarks\n{'AO2': 'Automated with precipitation sensor', 'SLP184': 'Sea level pressure: 1018.4 hPa', 'T00441078': 'Temperature 4.4\u00b0C and dewpoint -7.8\u00b0C'}\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process. Here's an example of a really bad day.</p> <pre><code>&gt;&gt;&gt; from avwx import Metar\n&gt;&gt;&gt; report = 'KSFO 031254Z 36024G55KT 320V040 1/8SM R06/0200D +TS VCFC OVC050 BKN040TCU 14/10 A2978 RMK AIRPORT CLOSED'\n&gt;&gt;&gt; ksfo = Metar.from_report(report)\nTrue\n&gt;&gt;&gt; ksfo.station.city\n'San Francisco'\n&gt;&gt;&gt; ksfo.last_updated\ndatetime.datetime(2018, 3, 4, 23, 54, 4, 353757, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; ksfo.data.flight_rules\n'LIFR'\n&gt;&gt;&gt; ksfo.translations.clouds\n'Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft - Reported AGL'\n&gt;&gt;&gt; ksfo.summary\n'Winds N-360 (variable 320 to 040) at 24kt gusting to 55kt, Vis 0.125sm, Temp 14C, Dew 10C, Alt 29.78inHg, Heavy Thunderstorm, Vicinity Funnel Cloud, Broken layer at 4000ft (Towering Cumulus), Overcast layer at 5000ft'\n</code></pre>"},{"location":"av/metar/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"av/metar/#code-str","title":"code: str","text":"<p>Station ident code the report was initialized with</p>"},{"location":"av/metar/#data-avwxstructsmetardata-none","title":"data: avwx.structs.MetarData = None","text":"<p>MetarData dataclass of parsed data values and units. Parsed on update()</p>"},{"location":"av/metar/#from_reportreport-str-avwxmetar","title":"from_report(report: str) -&gt; avwx.Metar","text":"<p>Returns an updated report object based on an existing report</p>"},{"location":"av/metar/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"av/metar/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the report was last updated</p>"},{"location":"av/metar/#parsereport-str-issued-optionaldate-none-bool","title":"parse(report: str, issued: Optional[date] = None) -&gt; bool","text":"<p>Updates report data by parsing a given report</p> <p>Can accept a report issue date if not a recent report string</p>"},{"location":"av/metar/#raw-str-none","title":"raw: str = None","text":"<p>The unparsed report string. Fetched on update()</p>"},{"location":"av/metar/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report string</p>"},{"location":"av/metar/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"av/metar/#speech-str","title":"speech: str","text":"<p>Report summary designed to be read by a text-to-speech program</p>"},{"location":"av/metar/#station-avwxstation","title":"station: avwx.Station","text":"<p>Provides basic station info</p>"},{"location":"av/metar/#summary-str","title":"summary: str","text":"<p>Condensed report summary created from translations</p>"},{"location":"av/metar/#translations-avwxstructsmetartrans-none","title":"translations: avwx.structs.MetarTrans = None","text":"<p>MetarTrans dataclass of translation strings from data. Parsed on update()</p>"},{"location":"av/metar/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"av/metar/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"av/metar/#class-avwxstructsmetardata","title":"class avwx.structs.MetarData","text":"<p>altimeter: avwx.structs.Number</p> <p>clouds: List[avwx.structs.Cloud]</p> <p>density_altitude: int</p> <p>dewpoint: avwx.structs.Number</p> <p>flight_rules: str</p> <p>other: List[str]</p> <p>pressure_altitude: int</p> <p>raw: str</p> <p>relative_humidity: str</p> <p>remarks: str</p> <p>remarks_info: avwx.structs.RemarksData</p> <p>runway_visibility: List[avwx.structs.RunwayVisibility]</p> <p>sanitized: str</p> <p>icao: str</p> <p>temperature: avwx.structs.Number</p> <p>time: avwx.structs.Timestamp</p> <p>visibility: avwx.structs.Number</p> <p>wind_direction: avwx.structs.Number</p> <p>wind_gust: avwx.structs.Number</p> <p>wind_speed: avwx.structs.Number</p> <p>wind_variable_direction: List[avwx.structs.Number]</p>"},{"location":"av/metar/#class-avwxstructsmetartrans","title":"class avwx.structs.MetarTrans","text":"<p>altimeter: str</p> <p>clouds: str</p> <p>dewpoint: str</p> <p>other: str</p> <p>remarks: dict</p> <p>temperature: str</p> <p>visibility: str</p> <p>wind: str</p>"},{"location":"av/notam/","title":"NOTAM","text":"<p>A NOTAM (Notice to Air Missions) is a report detailing special events or conditions affecting airport and flight operations. These can include, but are in no way limitted to:</p> <ul> <li>Runway closures</li> <li>Lack of radar services</li> <li>Rocket launches</li> <li>Hazard locations</li> <li>Airspace restrictions</li> <li>Construction updates</li> <li>Unusual aircraft activity</li> </ul> <p>NOTAMs have varius classifications and apply to certain types or size of aircraft. Some apply only to IFR operations, like when an ILS is out of service. Others apply only to airport operations the en route aircraft can ignore.</p> <p>Every NOTAM has a start and end date and time. Additional NOTAMs may be issued to update, replace, or cancel existing NOTAMs as well. Some NOTAMs may still be served up to 10 days after the end date, so it's up to the developer to include or filter these reports.</p>"},{"location":"av/notam/#class-avwxnotams","title":"class avwx.Notams()","text":"<p>The Notams class provides two ways of requesting all applicable NOTAMs in an area: airport code and coordinate. The service will fetch all reports within 10 nautical miles of the desired center point. You can change the distance by updating the <code>Notams.radius</code> member before calling <code>update()</code>.</p> <pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; from avwx import Notams\n&gt;&gt;&gt; from avwx.structs import Coord\n&gt;&gt;&gt;\n&gt;&gt;&gt; kjfk = Notams(\"KJFK\")\n&gt;&gt;&gt; kjfk.update()\nTrue\n&gt;&gt;&gt; kjfk.last_updated\ndatetime.datetime(2022, 5, 26, 0, 43, 22, 44753, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; print(kjfk.data[0].raw)\n01/113 NOTAMN\nQ) ZNY/QMXLC/IV/NBO/A/000/999/4038N07346W005\nA) KJFK\nB) 2101081328\nC) 2209301100\n\nE) TWY TB BTN TERMINAL 8 RAMP AND TWY A CLSD\n&gt;&gt;&gt; pprint(kjfk.data[0].qualifiers)\nQualifiers(repr='ZNY/QMXLC/IV/NBO/A/000/999/4038N07346W005',\n           fir='ZNY',\n           subject=Code(repr='MX', value='Taxiway'),\n           condition=Code(repr='LC', value='Closed'),\n           traffic=Code(repr='IV', value='IFR and VFR'),\n           purpose=[Code(repr='N', value='Immediate'),\n                    Code(repr='B', value='Briefing'),\n                    Code(repr='O', value='Flight Operations')],\n           scope=[Code(repr='A', value='Aerodrome')],\n           lower=Number(repr='000', value=0, spoken='zero'),\n           upper=Number(repr='999', value=999, spoken='nine nine nine'),\n           coord=Coord(lat=40.38, lon=-73.46, repr='4038N07346W'),\n           radius=Number(repr='005', value=5, spoken='five'))\n&gt;&gt;&gt;\n&gt;&gt;&gt; coord = Notams(coord=Coord(lat=52, lon=-0.23))\n&gt;&gt;&gt; coord.update()\nTrue\n&gt;&gt;&gt; coord.data[0].station\n'EGSS'\n&gt;&gt;&gt; print(coord.data[0].body)\nLONDON STANSTED ATC SURVEILLANCE MINIMUM ALTITUDE CHART - IN\nFREQUENCY BOX RENAME ESSEX RADAR TO STANSTED RADAR.\nUK AIP AD 2.EGSS-5-1 REFERS\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process.</p> <pre><code>&gt;&gt;&gt; from avwx import Notams\n&gt;&gt;&gt; report = \"\"\"\n05/295 NOTAMR\nQ) ZNY/QMNHW/IV/NBO/A/000/999/4038N07346W005\nA) KJFK\nB) 2205201527\nC) 2205271100\n\nE) APRON TERMINAL 4 RAMP CONST WIP S SIDE TAXILANE G LGTD AND BARRICADED\n\"\"\"\n&gt;&gt;&gt; kjfk = Notams.from_report(report)\n&gt;&gt;&gt; kjfk.data[0].type\nCode(repr='NOTAMR', value='Replace')\n&gt;&gt;&gt; kjfk.data[0].start_time\nTimestamp(repr='2205201527', dt=datetime.datetime(2022, 5, 20, 15, 27, tzinfo=datetime.timezone.utc))\n</code></pre>"},{"location":"av/notam/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"av/notam/#code-optionalstr","title":"code: Optional[str]","text":"<p>Station ident code the report was initialized with</p>"},{"location":"av/notam/#data-listavwxstructsnotamdata-none","title":"data: List[avwx.structs.NotamData] = None","text":"<p>List of NotamData dataclasses of parsed data values and units. Parsed on update()</p>"},{"location":"av/notam/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the reports were last updated</p>"},{"location":"av/notam/#coord-avwxstructscoord","title":"coord: avwx.structs.Coord","text":"<p>Coordinate of the radial center</p>"},{"location":"av/notam/#parsereports-unionstr-liststr-bool","title":"parse(reports: Union[str, List[str]]) -&gt; bool","text":"<p>Updates report data by parsing a given report</p>"},{"location":"av/notam/#radius-int-10","title":"radius: int = 10","text":"<p>Distance from the airport or coordinate location to filter fetched reports</p>"},{"location":"av/notam/#raw-liststr-none","title":"raw: List[str] = None","text":"<p>The unparsed report strings. Fetched on update()</p>"},{"location":"av/notam/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report strings</p>"},{"location":"av/notam/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"av/notam/#station-avwxstation-none","title":"station: avwx.Station = None","text":"<p>Provides basic station info</p>"},{"location":"av/notam/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"av/notam/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing recent aircraft reports</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"av/notam/#class-avwxstructsnotamdata","title":"class avwx.structs.NotamData","text":"<p>raw: str</p> <p>sanitized: str</p> <p>station: Optional[str]</p> <p>time: Optional[avwx.structs.Timestamp]</p> <p>remarks: Optional[str]</p> <p>number: Optional[str]</p> <p>replaces: Optional[str]</p> <p>type: Optional[avwx.structs.Code]</p> <p>qualifiers: Optional[avwx.structs.Qualifiers]</p> <p>start_time: Optional[avwx.structs.Timestamp]</p> <p>end_time: Optional[avwx.structs.Timestamp]</p> <p>schedule: Optional[str]</p> <p>body: str</p> <p>lower: Optional[avwx.structs.Number]</p> <p>upper: Optional[avwx.structs.Number]</p>"},{"location":"av/notam/#class-avwxstructsqualifiers","title":"class avwx.structs.Qualifiers","text":"<p>repr: str</p> <p>fir: str</p> <p>subject: Optional[avwx.structs.Code]</p> <p>condition: Optional[avwx.structs.Code]</p> <p>traffic: Optional[avwx.structs.Code]</p> <p>purpose: List[avwx.structs.Code]</p> <p>scope: List[avwx.structs.Code]</p> <p>lower: Optional[avwx.structs.Number]</p> <p>upper: Optional[avwx.structs.Number]</p> <p>coord: Coord</p> <p>radius: Optional[avwx.structs.Number]</p>"},{"location":"av/pirep/","title":"PIREP","text":"<p>A PIREP (Pilot Report) is an observation made by pilots inflight meant to aid controllers and pilots routing around adverse conditions and other conditions of note. They typically contain icing, turbulence, cloud types/bases/tops, and other info at a known distance and radial from a ground station. They are released as they come in.</p>"},{"location":"av/pirep/#class-avwxpirepscode-str-none-lat-float-none-lon-float-none","title":"class avwx.Pireps(code: str = None, lat: float = None, lon: float = None)","text":"<p>The Pireps class offers an object-oriented approach to managing multiple PIREP reports for a single station.</p> <p>Below is typical usage for fetching and pulling PIREP data for KJFK.</p> <pre><code>&gt;&gt;&gt; from avwx import Pireps\n&gt;&gt;&gt; kmco = Pireps(\"KMCO\")\n&gt;&gt;&gt; kmco.station.name\n'Orlando International Airport'\n&gt;&gt;&gt; kmco.update()\nTrue\n&gt;&gt;&gt; kmco.last_updated\ndatetime.datetime(2019, 5, 24, 13, 31, 46, 561732, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; kmco.raw[0]\n'FLL UA /OV KFLL275015/TM 1241/FL020/TP B737/SK TOP020/RM DURD RY10L'\n&gt;&gt;&gt; kmco.data[0].location\nLocation(repr='KFLL275015', station='KFLL', direction=Number(repr='275', value=275, spoken='two seven five'), distance=Number(repr='015', value=15, spoken='one five'))\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process.</p>"},{"location":"av/pirep/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"av/pirep/#code-optionalstr","title":"code: Optional[str]","text":"<p>Station ident code the report was initialized with</p>"},{"location":"av/pirep/#data-listavwxstructspirepdata-none","title":"data: List[avwx.structs.PirepData] = None","text":"<p>List of PirepData dataclasses of parsed data values and units. Parsed on update()</p>"},{"location":"av/pirep/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"av/pirep/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the reports were last updated</p>"},{"location":"av/pirep/#coord-avwxstructscoord","title":"coord: avwx.structs.Coord","text":"<p>Coordinate of the radial center</p>"},{"location":"av/pirep/#parsereports-unionstr-liststr-issued-optionaldate-none-bool","title":"parse(reports: Union[str, List[str]], issued: Optional[date] = None) -&gt; bool","text":"<p>Updates report data by parsing a given report</p> <p>Can accept a report issue date if not a recent report string</p>"},{"location":"av/pirep/#raw-liststr-none","title":"raw: List[str] = None","text":"<p>The unparsed report strings. Fetched on update()</p>"},{"location":"av/pirep/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report strings</p>"},{"location":"av/pirep/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"av/pirep/#station-avwxstation-none","title":"station: avwx.Station = None","text":"<p>Provides basic station info</p>"},{"location":"av/pirep/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"av/pirep/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing recent aircraft reports</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"av/pirep/#class-avwxstructspirepdata","title":"class avwx.structs.PirepData","text":"<p>aircraft: avwx.structs.Aircraft = None</p> <p>altitude: avwx.structs.Number = None</p> <p>clouds: List[avwx.structs.Cloud]</p> <p>flight_visibility: avwx.structs.Number = None</p> <p>icao: str</p> <p>icing: avwx.structs.Icing = None</p> <p>location: avwx.structs.Location = None</p> <p>other: List[str]</p> <p>raw: str</p> <p>remarks: str</p> <p>sanitized: str</p> <p>temperature: avwx.structs.Number = None</p> <p>time: avwx.structs.Timestamp</p> <p>turbulence: avwx.structs.Turbulence = None</p> <p>type: str</p> <p>wx_codes: List[avwx.structs.Code]</p>"},{"location":"av/taf/","title":"TAF","text":"<p>A TAF (Terminal Aerodrome Forecast) is a 24-hour weather forecast for the area 5 statute miles from the reporting station. They are update once every three or six hours or when significant changes warrant an update, and the observations are valid for six hours or until the next report is issued</p>"},{"location":"av/taf/#class-avwxtafcode-str","title":"class avwx.Taf(code: str)","text":"<p>The Taf class offers an object-oriented approach to managing TAF data for a single station.</p> <pre><code>&gt;&gt;&gt; from avwx import Taf\n&gt;&gt;&gt; kjfk = Taf(\"KJFK\")\n&gt;&gt;&gt; kjfk.station.name\n'John F Kennedy International Airport'\n&gt;&gt;&gt; kjfk.update()\nTrue\n&gt;&gt;&gt; kjfk.last_updated\ndatetime.datetime(2018, 3, 4, 23, 43, 26, 209644, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; kjfk.raw\n'KJFK 042030Z 0421/0524 33016G27KT P6SM BKN045 FM051600 36016G22KT P6SM BKN040 FM052100 35013KT P6SM SCT035'\n&gt;&gt;&gt; len(kjfk.data.forecast)\n3\n&gt;&gt;&gt; kjfk.data.forecast[0].flight_rules\n'VFR'\n&gt;&gt;&gt; kjfk.translations.forecast[0].wind\n'NNW-330 at 16kt gusting to 27kt'\n&gt;&gt;&gt; kjfk.speech\n'Starting on March 4th - From 21 to 16 zulu, Winds three three zero at 16kt gusting to 27kt. Visibility greater than six miles. Broken layer at 4500ft. From 16 to 21 zulu, Winds three six zero at 16kt gusting to 22kt. Visibility greater than six miles. Broken layer at 4000ft. From 21 to midnight zulu, Winds three five zero at 13kt. Visibility greater than six miles. Scattered clouds at 3500ft'\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process.</p> <pre><code>&gt;&gt;&gt; from avwx import Taf\n&gt;&gt;&gt; report = \"TAF ZYHB 082300Z 0823/0911 VRB03KT 9999 SCT018 BKN120 TX14/0907Z TN04/0921Z FM090100 09015KT 9999 -SHRA WS020/13045KT SCT018 BKN120 BECMG 0904/0906 34008KT PROB30 TEMPO 0906/0911 7000 -RA SCT020 650104 530804 RMK FCST BASED ON AUTO OBS. NXT FCST BY 090600Z\"\n&gt;&gt;&gt; zyhb = Taf.from_report(report)\nTrue\n&gt;&gt;&gt; zyhb.station.city\n'Hulan'\n&gt;&gt;&gt; zyhb.data.remarks\n'RMK FCST BASED ON AUTO OBS. NXT FCST BY 090600Z'\n&gt;&gt;&gt; zyhb.summary[-1]\n'Vis 7km, Light Rain, Scattered clouds at 2000ft, Frequent moderate turbulence in clear air from 8000ft to 12000ft, Moderate icing in clouds from 1000ft to 5000ft'\n</code></pre>"},{"location":"av/taf/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"av/taf/#code-str","title":"code: str","text":"<p>Station ident code the report was initialized with</p>"},{"location":"av/taf/#data-avwxstructstafdata-none","title":"data: avwx.structs.TafData = None","text":"<p>TafData dataclass of parsed data values and units. Parsed on update()</p>"},{"location":"av/taf/#from_reportreport-str-avwxtaf","title":"from_report(report: str) -&gt; avwx.Taf","text":"<p>Returns an updated report object based on an existing report</p>"},{"location":"av/taf/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"av/taf/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the report was last updated</p>"},{"location":"av/taf/#parsereport-str-issued-optionaldate-none-bool","title":"parse(report: str, issued: Optional[date] = None) -&gt; bool","text":"<p>Updates report data by parsing a given report</p> <p>Can accept a report issue date if not a recent report string</p>"},{"location":"av/taf/#raw-str-none","title":"raw: str = None","text":"<p>The unparsed report string. Fetched on update()</p>"},{"location":"av/taf/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report string</p>"},{"location":"av/taf/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"av/taf/#speech-str","title":"speech: str","text":"<p>Report summary designed to be read by a text-to-speech program</p>"},{"location":"av/taf/#station-avwxstation","title":"station: avwx.Station","text":"<p>Provides basic station info</p>"},{"location":"av/taf/#summary-str","title":"summary: [str]","text":"<p>Condensed report summaries created from translations</p>"},{"location":"av/taf/#translations-avwxstructstaftrans","title":"translations: avwx.structs.TafTrans","text":"<p>TafTrans dataclass of translation strings from data. Parsed on update()</p>"},{"location":"av/taf/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"av/taf/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"av/taf/#class-avwxstructstafdata","title":"class avwx.structs.TafData","text":"<p>alts: str = None</p> <p>end_time: avwx.structs.Timestamp</p> <p>forecast: List[avwx.structs.TafLineData]</p> <p>max_temp: float = None</p> <p>min_temp: float = None</p> <p>raw: str</p> <p>remarks: str</p> <p>start_time: avwx.structs.Timestamp</p> <p>icao: str</p> <p>temps: List[str] = None</p> <p>time: avwx.structs.Timestamp</p>"},{"location":"av/taf/#class-avwxstructstaftrans","title":"class avwx.structs.TafTrans","text":"<p>forecast: List[avwx.structs.TafLineTrans]</p> <p>max_temp: str</p> <p>min_temp: str</p> <p>remarks: dict</p>"},{"location":"av/taf/#class-avwxstructstaflinedata","title":"class avwx.structs.TafLineData","text":"<p>altimeter: avwx.structs.Number</p> <p>clouds: List[avwx.structs.Cloud]</p> <p>end_time: avwx.structs.Timestamp</p> <p>flight_rules: str</p> <p>icing: List[str]</p> <p>other: List[str]</p> <p>probability: avwx.structs.Number</p> <p>raw: str</p> <p>sanitized: str</p> <p>start_time: avwx.structs.Timestamp</p> <p>transition_start: avwx.structs.Timestamp</p> <p>turbulence: List[str]</p> <p>type: str</p> <p>visibility: avwx.structs.Number</p> <p>wind_direction: avwx.structs.Number</p> <p>wind_gust: avwx.structs.Number</p> <p>wind_shear: str</p> <p>wind_speed: avwx.structs.Number</p> <p>wind_variable_direction: List[avwx.structs.Number]</p>"},{"location":"av/taf/#class-avwxstructstaflinetrans","title":"class avwx.structs.TafLineTrans","text":"<p>altimeter: str</p> <p>clouds: str</p> <p>icing: str</p> <p>other: str</p> <p>turbulence: str</p> <p>visibility: str</p> <p>wind: str</p> <p>wind_shear: str</p>"},{"location":"gfs/mav/","title":"GFS MOS MAV","text":"<p>The MAV report is a short-range forecast (6-72 hours) based on the Global Forecast System model output and is only valid for ICAO stations in the United States, Puerto Rico, and US Virgin Islands. Reports are published every six hours starting at 0000 UTC.</p>"},{"location":"gfs/mav/#class-avwxmavcode-str","title":"class avwx.Mav(code: str)","text":"<p>The Mav class offers an object-oriented approach to managing MOS MAV data for a single station.</p> <p>Below is typical usage for fetching and pulling MAV data for KJFK.</p> <pre><code>&gt;&gt;&gt; from avwx import Mav\n&gt;&gt;&gt; kjfk = Mav(\"KJFK\")\n&gt;&gt;&gt; kjfk.station.name\n'John F Kennedy International Airport'\n&gt;&gt;&gt; kjfk.update()\nTrue\n&gt;&gt;&gt; kjfk.last_updated\ndatetime.datetime(2020, 4, 20, 1, 7, 7, 393270, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; print(kjfk.raw)\n\"\"\"\nKJFK   GFS MOS GUIDANCE    4/19/2020  1800 UTC\nDT /APR  20                  /APR  21                /APR  22\nHR   00 03 06 09 12 15 18 21 00 03 06 09 12 15 18 21 00 03 06 12 18\nN/X              46          58          44          58       37\nTMP  53 52 50 48 48 50 54 56 51 49 47 46 49 53 55 52 47 45 43 41 54\nDPT  43 41 37 35 33 30 28 27 28 30 32 34 37 39 37 32 26 23 22 18 14\nCLD  OV OV OV OV OV OV OV SC FW CL CL FW BK OV OV OV BK FW CL FW SC\nWDR  20 22 26 35 02 03 02 02 34 19 20 18 18 18 18 23 29 30 29 29 28\nWSP  20 13 07 08 11 14 14 11 05 03 04 06 11 19 25 21 22 25 20 19 22\nP06         0    12     9     1     0     1    29    68     8  2  0\nP12              12           9           2          69       15\nQ06         0     0     0     0     0     0     0     2     0  0  0\nQ12               0           0           0           2        0\nT06      0/ 4  1/ 0  1/ 0  0/ 0  0/ 0  0/ 0  5/ 3 13/13  0/ 0  0/ 8\nT12                  1/ 2        0/ 0        9/ 6       14/13  1/ 8\nPOZ   0  1  1  0  0  0  0  0  0  0  0  0  0  0  0  1  0  0  0  0  0\nPOS   0  0  0  0  0  2  0  6  6  9  9  0 16  8  0  4  4 47 60 67 42\nTYP   R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  R  S  S  R\nSNW                                       0                    0\nCIG   7  7  7  7  6  6  6  8  8  8  8  8  8  6  6  6  7  8  8  8  8\nVIS   7  7  7  7  7  7  7  7  7  7  7  7  7  7  7  6  7  7  7  7  7\nOBV   N  N  N  N  N  N  N  N  N  N  N  N  N  N  N  N  N  N  N  N  N\n\"\"\"\n&gt;&gt;&gt; len(kjfk.data.forecast)\n21\n&gt;&gt;&gt; kjfk.data.forecast[0].ceiling\nCode(repr='7', value='6600 - 12,000 feet')\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process.</p>"},{"location":"gfs/mav/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"gfs/mav/#code-str","title":"code: str","text":"<p>Station ident code the report was initialized with</p>"},{"location":"gfs/mav/#data-avwxstructsmavdata-none","title":"data: avwx.structs.MavData = None","text":"<p>MavData dataclass of parsed data values and units. Parsed on update()</p>"},{"location":"gfs/mav/#from_reportreport-str-avwxmav","title":"from_report(report: str) -&gt; avwx.Mav","text":"<p>Returns an updated report object based on an existing report</p>"},{"location":"gfs/mav/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"gfs/mav/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the report was last updated</p>"},{"location":"gfs/mav/#parsereport-str-bool","title":"parse(report: str) -&gt; bool","text":"<p>Updates report data by parsing a given report</p>"},{"location":"gfs/mav/#raw-str-none","title":"raw: str = None","text":"<p>The unparsed report string. Fetched on update()</p>"},{"location":"gfs/mav/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report string</p>"},{"location":"gfs/mav/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"gfs/mav/#station-avwxstation","title":"station: avwx.Station","text":"<p>Provides basic station info</p>"},{"location":"gfs/mav/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"gfs/mav/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"gfs/mav/#class-avwxstructsmavdata","title":"class avwx.structs.MavData","text":"<p>forecast: List[avwx.structs.MavPeriod]</p> <p>raw: str</p> <p>station: str</p> <p>time: avwx.structs.Timestamp</p>"},{"location":"gfs/mav/#class-avwxstructsmavperiod","title":"class avwx.structs.MavPeriod","text":"<p>ceiling: avwx.structs.Code</p> <p>cloud: avwx.structs.Code</p> <p>dewpoint: avwx.structs.Number</p> <p>freezing_precip: avwx.structs.Number</p> <p>precip_amount_6: avwx.structs.Code</p> <p>precip_amount_12: avwx.structs.Code</p> <p>precip_chance_6: avwx.structs.Number</p> <p>precip_chance_12: avwx.structs.Number</p> <p>precip_type: avwx.structs.Code</p> <p>severe_storm_6: avwx.structs.Number</p> <p>severe_storm_12: avwx.structs.Number</p> <p>snow: avwx.structs.Number</p> <p>temperature: avwx.structs.Number</p> <p>thunderstorm_6: avwx.structs.Number</p> <p>thunderstorm_12: avwx.structs.Number</p> <p>time: avwx.structs.Timestamp</p> <p>vis_obstruction: avwx.structs.Code</p> <p>visibility: avwx.structs.Code</p> <p>wind_direction: avwx.structs.Number</p> <p>wind_speed: avwx.structs.Number</p>"},{"location":"gfs/mex/","title":"GFS MOS MEX","text":"<p>The MEX report is an extended-range forecast (24-192 hours) based on the Global Forecast System model output and is only valid for ICAO stations in the United States, Puerto Rico, and US Virgin Islands. Reports are published at 0000 and 1200 UTC.</p>"},{"location":"gfs/mex/#class-avwxmexcode-str","title":"class avwx.Mex(code: str)","text":"<p>The Mex class offers an object-oriented approach to managing MOS MEX data for a single station.</p> <p>Below is typical usage for fetching and pulling MAV data for KJFK.</p> <pre><code>&gt;&gt;&gt; from avwx import Mex\n&gt;&gt;&gt; kjfk = Mex(\"KJFK\")\n&gt;&gt;&gt; kjfk.station.name\n'John F Kennedy International Airport'\n&gt;&gt;&gt; kjfk.update()\nTrue\n&gt;&gt;&gt; kjfk.last_updated\ndatetime.datetime(2020, 4, 20, 12, 7, 7, 393270, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; print(kjfk.raw)\n\"\"\"\nKJFK   GFSX MOS GUIDANCE   4/20/2020  0000 UTC\nFHR  24| 36  48| 60  72| 84  96|108 120|132 144|156 168|180 192\nMON  20| TUE 21| WED 22| THU 23| FRI 24| SAT 25| SUN 26| MON 27 CLIMO\nX/N  57| 45  59| 37  56| 40  52| 49  58| 46  59| 48  59| 44  58 45 63\nTMP  50| 49  48| 41  49| 45  48| 52  51| 50  53| 51  52| 48  51\nDPT  31| 39  26| 17  17| 24  40| 46  43| 40  44| 43  40| 35  31\nCLD  OV| OV  OV| CL  CL| OV  OV| OV  OV| PC  OV| OV  OV| OV  OV\nWND  13| 14  26| 26  21| 16  13| 18  15| 16  12| 15  19| 19  11\nP12   9|  1  73|  7   0|  9  43| 73  63| 27  51| 64  37| 35  32 24 23\nP24    |     73|      7|     43|     77|     61|     73|     44    36\nQ12   0|  0   2|  0   0|  0   1|  5   3|  0   2|  5    |\nQ24    |      1|      0|      0|      5|      2|       |\nT12   1|  0  12|  1   0|  4   4|  8  11|  3   3| 14   7|  5   9\nT24    |  1    | 14    |  4    | 12    | 11    | 14    | 11\nPZP   0|  0   1|  0   2|  4   1|  0   0|  0   0|  0   0|  0   0\nPSN   0|  0   0| 37  25| 15   4|  0   0|  0   0|  2   0|  3   5\nPRS   0|  2   1| 32  28| 19   4|  0   1|  1   1|  1   1|  8   9\nTYP   R|  R   R| RS  RS|  R   R|  R   R|  R   R|  R   R|  R   R\nSNW    |      0|      0|      0|      0|      0|       |\n\"\"\"\n&gt;&gt;&gt; len(kjfk.data.forecast)\n15\n&gt;&gt;&gt; kjfk.data.forecast[2].precip_chance_24\nNumber(repr='73', value=73, spoken='seven three')\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process.</p>"},{"location":"gfs/mex/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"gfs/mex/#code-str","title":"code: str","text":"<p>Station ident code the report was initialized with</p>"},{"location":"gfs/mex/#data-avwxstructsmexdata-none","title":"data: avwx.structs.MexData = None","text":"<p>MavData dataclass of parsed data values and units. Parsed on update()</p>"},{"location":"gfs/mex/#from_reportreport-str-avwxmex","title":"from_report(report: str) -&gt; avwx.Mex","text":"<p>Returns an updated report object based on an existing report</p>"},{"location":"gfs/mex/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"gfs/mex/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the report was last updated</p>"},{"location":"gfs/mex/#parsereport-str-bool","title":"parse(report: str) -&gt; bool","text":"<p>Updates report data by parsing a given report</p>"},{"location":"gfs/mex/#raw-str-none","title":"raw: str = None","text":"<p>The unparsed report string. Fetched on update()</p>"},{"location":"gfs/mex/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report string</p>"},{"location":"gfs/mex/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"gfs/mex/#station-avwxstation","title":"station: avwx.Station","text":"<p>Provides basic station info</p>"},{"location":"gfs/mex/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"gfs/mex/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"gfs/mex/#class-avwxstructsmexdata","title":"class avwx.structs.MexData","text":"<p>forecast: List[avwx.structs.MexPeriod]</p> <p>raw: str</p> <p>station: str</p> <p>time: avwx.structs.Timestamp</p>"},{"location":"gfs/mex/#class-avwxstructsmexperiod","title":"class avwx.structs.MexPeriod","text":"<p>cloud: avwx.structs.Code</p> <p>dewpoint: avwx.structs.Number</p> <p>freezing_precip: avwx.structs.Number</p> <p>precip_amount_12: avwx.structs.Code</p> <p>precip_amount_24: avwx.structs.Code</p> <p>precip_chance_12: avwx.structs.Number</p> <p>precip_chance_24: avwx.structs.Number</p> <p>precip_type: avwx.structs.Code</p> <p>rain_snow_mix: avwx.structs.Number</p> <p>severe_storm_12: avwx.structs.Number</p> <p>severe_storm_24: avwx.structs.Number</p> <p>snow_amount_24: avwx.structs.Code</p> <p>snow: avwx.structs.Number</p> <p>temperature: avwx.structs.Number</p> <p>thunderstorm_12: avwx.structs.Number</p> <p>thunderstorm_24: avwx.structs.Number</p> <p>time: avwx.structs.Timestamp</p>"},{"location":"nbm/nbe/","title":"NBM NBE","text":"<p>The NBE report is an extended-range forecast (24-192 hours) based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 12-hour increments and published near the top of every hour.</p>"},{"location":"nbm/nbe/#class-avwxnbecode-str","title":"class avwx.Nbe(code: str)","text":"<p>Class to handle NBM NBE report data</p> <p>Below is typical usage for fetching and pulling NBE data for KJFK.</p> <pre><code>&gt;&gt;&gt; from avwx import Nbe\n&gt;&gt;&gt; kjfk = Nbe(\"KJFK\")\n&gt;&gt;&gt; kjfk.station.name\n'John F Kennedy International Airport'\n&gt;&gt;&gt; kjfk.update()\nTrue\n&gt;&gt;&gt; kjfk.last_updated\ndatetime.datetime(2020, 7, 28, 1, 23, 4, 909939, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; print(kjfk.raw)\n\"\"\"\nKJFK    NBM V3.2 NBE GUIDANCE    7/28/2020  0000 UTC\n       WED 29| THU 30| FRI 31| SAT 01| SUN 02| MON 03| TUE 04|WED CLIMO\nUTC    00  12| 00  12| 00  12| 00  12| 00  12| 00  12| 00  12| 00\nFHR    24  36| 48  60| 72  84| 96 108|120 132|144 156|168 180|192\nX/N    93  76| 91  76| 90  74| 86  72| 87  73| 85  74| 86  72| 84 68 83\nTMP    84  80| 83  80| 81  78| 78  76| 78  78| 78  78| 78  76| 76\nDPT    72  69| 68  69| 71  68| 67  66| 68  69| 70  71| 70  68| 69\nSKY    61  21| 23  47| 80  73| 47  31| 30  54| 68  65| 66  59| 32\nWDR    25  35| 20  26| 20   2| 16   1| 16   7| 16  24| 22  34| 18\nWSP     5   2|  6   3|  5   4|  3   5|  7   4|  6   4|  5   4|  4\nGST    11   4| 13   6| 13  10|  9  10| 13   7| 13   9| 16   9| 12\nP12    48  23|  8   1| 23  28| 28  16| 18  17| 30  41| 46  31| 32 19 18\nQ12    10   0|  0   0|  0   0|  0   0|  0   0|  0  64| 77  81| 83\nQ24          |  0    |  0    |  0    |  0    |  0    |141    |164\nDUR     2   1|  0   0|  0   0|  0   0|  0   0|  2  12| 12  12| 12\nT12    46  32|  6   8| 21  22| 17   5|  6   5| 25  23| 19  18| 18\nPZR     0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0\nPSN     0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0\nPPL     0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0\nPRA   100 100|100 100|100 100|100 100|100 100|100 100|100 100|100\nS12     0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0\nSLV   138 114|111 119|119 121|113 101|108 117|134 132|124 123|121\nI12     0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0   0|  0\nS24          |  0    |  0    |  0    |  0    |  0    |  0    |  0\nSOL   100 320|190 230|270 250|360 290|370  30|190 260|250 230|450\n\"\"\"\n&gt;&gt;&gt; len(kjfk.data.forecast)\n25\n&gt;&gt;&gt; kjfk.data.forecast[0].wind_direction\nNumber(repr='25', value=250, spoken='two five zero')\n&gt;&gt;&gt; print(kjfk.data.forecast[1].precip_duration.value, kjfk.units.duration)\n1 hour\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process.</p>"},{"location":"nbm/nbe/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"nbm/nbe/#code-str","title":"code: str","text":"<p>Station ident code the report was initialized with</p>"},{"location":"nbm/nbe/#data-avwxstructsnbedata-none","title":"data: avwx.structs.NbeData = None","text":"<p>NbeData dataclass of parsed data values and units. Parsed on update()</p>"},{"location":"nbm/nbe/#from_reportreport-str-avwxnbe","title":"from_report(report: str) -&gt; avwx.Nbe","text":"<p>Returns an updated report object based on an existing report</p>"},{"location":"nbm/nbe/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"nbm/nbe/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the report was last updated</p>"},{"location":"nbm/nbe/#parsereport-str-bool","title":"parse(report: str) -&gt; bool","text":"<p>Updates report data by parsing a given report</p>"},{"location":"nbm/nbe/#raw-str-none","title":"raw: str = None","text":"<p>The unparsed report string. Fetched on update()</p>"},{"location":"nbm/nbe/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report string</p>"},{"location":"nbm/nbe/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"nbm/nbe/#station-avwxstation","title":"station: avwx.Station","text":"<p>Provides basic station info</p>"},{"location":"nbm/nbe/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"nbm/nbe/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"nbm/nbe/#class-avwxstructsnbedata","title":"class avwx.structs.NbeData","text":"<p>forecast: List[avwx.structs.NbePeriod]</p> <p>raw: str</p> <p>station: str</p> <p>time: avwx.structs.Timestamp</p>"},{"location":"nbm/nbe/#class-avwxstructsnbeperiod","title":"class avwx.structs.NbePeriod","text":"<p>dewpoint: avwx.structs.Number</p> <p>freezing_precip: avwx.structs.Number</p> <p>icing_amount_12: avwx.structs.Number</p> <p>precip_amount_12: avwx.structs.Number</p> <p>precip_amount_24: avwx.structs.Number</p> <p>precip_chance_12: avwx.structs.Number</p> <p>precip_duration: avwx.structs.Number</p> <p>rain: avwx.structs.Number</p> <p>sky_cover: avwx.structs.Number</p> <p>sleet: avwx.structs.Number</p> <p>snow_amount_12: avwx.structs.Number</p> <p>snow_amount_24: avwx.structs.Number</p> <p>snow_level: avwx.structs.Number</p> <p>snow: avwx.structs.Number</p> <p>solar_radiation: avwx.structs.Number</p> <p>temperature: avwx.structs.Number</p> <p>thunderstorm_12: avwx.structs.Number</p> <p>time: avwx.structs.Timestamp</p> <p>wave_height: avwx.structs.Number</p> <p>wind_direction: avwx.structs.Number</p> <p>wind_gust: avwx.structs.Number</p> <p>wind_speed: avwx.structs.Number</p>"},{"location":"nbm/nbh/","title":"NBM NBH","text":"<p>The NBH report is a 25-hour forecast based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 1-hour increments and are published near the top of every hour.</p>"},{"location":"nbm/nbh/#class-avwxnbhcode-str","title":"class avwx.Nbh(code: str)","text":"<p>Class to handle NBM NBH report data</p> <p>Below is typical usage for fetching and pulling NBH data for KJFK.</p> <pre><code>&gt;&gt;&gt; from avwx import Nbh\n&gt;&gt;&gt; kjfk = Nbh(\"KJFK\")\n&gt;&gt;&gt; kjfk.station.name\n'John F Kennedy International Airport'\n&gt;&gt;&gt; kjfk.update()\nTrue\n&gt;&gt;&gt; kjfk.last_updated\ndatetime.datetime(2020, 7, 26, 20, 37, 42, 352220, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; print(kjfk.raw)\n\"\"\"\nKJFK   NBM V3.2 NBH GUIDANCE    7/26/2020  1900 UTC\nUTC  20 21 22 23 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20\nTMP  90 89 88 87 85 84 82 81 81 80 79 78 77 76 76 78 81 84 87 89 90 91 92 92 93\nDPT  69 68 66 66 65 65 65 66 66 66 66 67 67 66 67 67 67 67 67 68 67 67 67 67 67\nSKY   9 14 41 58 61 71 66 55 39 37 39 43 40 38 29 21 19 26 24 27 22 14 22 26 26\nWDR  22 22 23 24 25 25 25 25 25 25 25 26 26 26 26 26 26 26 25 24 24 23 23 22 23\nWSP  10  9  9  8  7  6  5  5  5  6  5  5  5  5  4  4  5  5  7  8  8  9 10 10 10\nGST  17 16 16 15 14 12 11 12 12 12 12 11 11  9  9  9  9 10 11 13 14 15 16 17 17\nP01   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nP06                                 0                 0                 0\nQ01   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nDUR                                                   0\nT01   1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nPZR   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nPSN   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nPPL   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nPRA 100100100100100100100100100100100100100100100100100100100100100100100100100\nS01   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nSLV  99101102103105105105106105104106104104104104103102100 99 98 98 99100101102\nI01   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nCIG 888888888360360350340888888888888888888888888888888888888888888888888888888\nVIS 110120120140140130120120120120110110110110110120130140150150150150150150150\nLCB  80 60999999999999999999999999999999999999999999999999999999999999999999999\nMHT  26 26 20 19  8  7  6  4  4  5  5  5  6  4  5  6  6 11 20 27 37 39 43 39 31\nTWD  24 26 26 27 26 26 24 23 24 26 26 26 27 27 28 27 27 27 27 26 26 26 25 25 24\nTWS  15 14 14 13 11 11 11 10 11 11 10 11 10  8  8  7  8  9 12 13 14 15 17 17 16\nHID                                 6                 5                 6\nSOL 710500430250110  0 30  0  0  0  0  0  0  0 30160330500650760830870870850720\n\"\"\"\n&gt;&gt;&gt; len(kjfk.data.forecast)\n25\n&gt;&gt;&gt; kjfk.data.forecast[0].snow_level\nNumber(repr='99', value=9900, spoken='nine nine hundred')\n&gt;&gt;&gt; print(kjfk.data.forecast[0].solar_radiation.value, kjfk.units.solar_radiation)\n710 W/m2\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process.</p>"},{"location":"nbm/nbh/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"nbm/nbh/#code-str","title":"code: str","text":"<p>Station ident code the report was initialized with</p>"},{"location":"nbm/nbh/#data-avwxstructsnbhdata-none","title":"data: avwx.structs.NbhData = None","text":"<p>NbhData dataclass of parsed data values and units. Parsed on update()</p>"},{"location":"nbm/nbh/#from_reportreport-str-avwxnbh","title":"from_report(report: str) -&gt; avwx.Nbh","text":"<p>Returns an updated report object based on an existing report</p>"},{"location":"nbm/nbh/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"nbm/nbh/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the report was last updated</p>"},{"location":"nbm/nbh/#parsereport-str-bool","title":"parse(report: str) -&gt; bool","text":"<p>Updates report data by parsing a given report</p>"},{"location":"nbm/nbh/#raw-str-none","title":"raw: str = None","text":"<p>The unparsed report string. Fetched on update()</p>"},{"location":"nbm/nbh/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report string</p>"},{"location":"nbm/nbh/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"nbm/nbh/#station-avwxstation","title":"station: avwx.Station","text":"<p>Provides basic station info</p>"},{"location":"nbm/nbh/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"nbm/nbh/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"nbm/nbh/#class-avwxstructsnbhdata","title":"class avwx.structs.NbhData","text":"<p>forecast: List[avwx.structs.NbhPeriod]</p> <p>raw: str</p> <p>station: str</p> <p>time: avwx.structs.Timestamp</p>"},{"location":"nbm/nbh/#class-avwxstructsnbhperiod","title":"class avwx.structs.NbhPeriod","text":"<p>ceiling: avwx.structs.Number</p> <p>cloud_base: avwx.structs.Number</p> <p>dewpoint: avwx.structs.Number</p> <p>freezing_precip: avwx.structs.Number</p> <p>haines: List[avwx.structs.Number]</p> <p>icing_amount_1: avwx.structs.Number</p> <p>mixing_height: avwx.structs.Number</p> <p>precip_amount_1: avwx.structs.Number</p> <p>precip_chance_1: avwx.structs.Number</p> <p>precip_chance_6: avwx.structs.Number</p> <p>precip_duration: avwx.structs.Number</p> <p>rain: avwx.structs.Number</p> <p>sky_cover: avwx.structs.Number</p> <p>sleet: avwx.structs.Number</p> <p>snow_amount_1: avwx.structs.Number</p> <p>snow_level: avwx.structs.Number</p> <p>snow: avwx.structs.Number</p> <p>solar_radiation: avwx.structs.Number</p> <p>temperature: avwx.structs.Number</p> <p>thunderstorm_1: avwx.structs.Number</p> <p>time: avwx.structs.Timestamp</p> <p>transport_wind_direction: avwx.structs.Number</p> <p>transport_wind_speed: avwx.structs.Number</p> <p>visibility: avwx.structs.Number</p> <p>wave_height: avwx.structs.Number</p> <p>wind_direction: avwx.structs.Number</p> <p>wind_gust: avwx.structs.Number</p> <p>wind_speed: avwx.structs.Number</p>"},{"location":"nbm/nbs/","title":"NBM NBS","text":"<p>The NBS report is a short-range forecast (6-72 hours) based on the National Blend of Models and is only valid for ICAO stations in the United States and Puerto Rico, and US Virgin Islands. Reports are in 3-hour increments and published near the top of every hour.</p>"},{"location":"nbm/nbs/#class-avwxnbscode-str","title":"class avwx.Nbs(code: str)","text":"<p>Class to handle NBM NBS report data</p> <p>Below is typical usage for fetching and pulling Nbs data for KJFK.</p> <pre><code>&gt;&gt;&gt; from avwx import Nbs\n&gt;&gt;&gt; kjfk = Nbs(\"KJFK\")\n&gt;&gt;&gt; kjfk.station.name\n'John F Kennedy International Airport'\n&gt;&gt;&gt; kjfk.update()\nTrue\n&gt;&gt;&gt; kjfk.last_updated\ndatetime.datetime(2020, 7, 28, 1, 3, 46, 447635, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; print(kjfk.raw)\n\"\"\"\nKJFK    NBM V3.2 NBS GUIDANCE    7/27/2020  2300 UTC\nDT /JULY 28               /JULY 29                /JULY 30\nUTC  03 06 09 12 15 18 21 00 03 06 09 12 15 18 21 00 03 06 09 12 15 18 21\nFHR  04 07 10 13 16 19 22 25 28 31 34 37 40 43 46 49 52 55 58 61 64 67 70\nN/X           79          93          76          91          76\nTMP  85 82 80 83 89 91 89 84 81 79 77 80 85 89 87 83 81 79 77 80 86 88 86\nDPT  70 70 71 72 72 72 73 72 72 71 69 69 68 67 68 69 68 67 68 69 68 69 70\nSKY   4 10  2  4 12 23 38 61 53 62 51 26 19  9 21 24 25 34 32 45 57 70 79\nWDR  23 24 23 24 24 22 23 27 28 28 34 35 21 20 19 22 23 25 26 26 23 20 20\nWSP   8  8  5  6  8  9  7  5  3  2  1  2  3  6  9  7  4  4  3  3  4  7  8\nGST  16 15 11 11 13 15 15 11  9  5  4  4  6 12 15 13 11 11  8  6  7 13 15\nP06      0     1    15    48    17    11     8     8     1     0     5\nP12            1          48          17           8           1\nQ06      0     0     0    11     0     0     0     0     0     0     0\nQ12            0          11           0           0           0\nDUR            0           2           0           0           0\nT03   2  3  1  1  2 10 27 30 21 13  8  5  1  0  2  3  4  3  2  3  1  3  7\nT12            4          48          33           6           8\nPZR   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nPSN   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nPPL   0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\nPRA 100100100100100100100100100100100100100100100100100100100100100100100\nS06      0     0     0     0     0     0     0     0     0     0     0\nSLV 108112113133135139141139137134124113102 99107115114118118119118118118\nI06      0     0     0     0     0     0     0     0     0     0     0\nCIG 888888888888888888888170888150888888888888888888888888888888888888888\nVIS 120120110120130130130110110110110130110110110120120120110110110110110\nLCB  60 70999 90 90999 50 60 60 60 60 60 22999999200230 70 80 60 60150 60\nMHT   7  6  5 13 30 46 19 15  7  7 10 16 40 35 13  4  4  4  9 18 31 27 13\nTWD  23 24 23 27 25 24 27 27 28 21 34  6 26 23 20 19 26 23 27 29 24 20 18\nTWS  17 16  9 11 13 16 12  9  5  5  4  3  4  8 11 10  8 10 10  6  6  9 13\nHID      4     4     4     4     3     4     4     5     5     3     4\nSOL   0  0  0320700760360100  0  0  0320720830620190  0  0  0230480570540\n\"\"\"\n&gt;&gt;&gt; len(kjfk.data.forecast)\n23\n&gt;&gt;&gt; kjfk.data.forecast[0].ceiling\nNumber(repr='888', value=None, spoken='unlimited')\n&gt;&gt;&gt; print(kjfk.data.forecast[7].precip_amount_12.value, kjfk.units.accumulation)\n0.11 in\n</code></pre> <p>The <code>parse</code> and <code>from_report</code> methods can parse a report string if you want to override the normal fetching process.</p>"},{"location":"nbm/nbs/#async-async_updatetimeout-int-10-bool","title":"async async_update(timeout: int = 10) -&gt; bool","text":"<p>Async updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"nbm/nbs/#code-str","title":"code: str","text":"<p>Station ident code the report was initialized with</p>"},{"location":"nbm/nbs/#data-avwxstructsnbsdata-none","title":"data: avwx.structs.NbsData = None","text":"<p>NbsData dataclass of parsed data values and units. Parsed on update()</p>"},{"location":"nbm/nbs/#from_reportreport-str-avwxnbs","title":"from_report(report: str) -&gt; avwx.Nbs","text":"<p>Returns an updated report object based on an existing report</p>"},{"location":"nbm/nbs/#issued-date-none","title":"issued: date = None","text":"<p>UTC date object when the report was issued</p>"},{"location":"nbm/nbs/#last_updated-datetimedatetime-none","title":"last_updated: datetime.datetime = None","text":"<p>UTC Datetime object when the report was last updated</p>"},{"location":"nbm/nbs/#parsereport-str-bool","title":"parse(report: str) -&gt; bool","text":"<p>Updates report data by parsing a given report</p>"},{"location":"nbm/nbs/#raw-str-none","title":"raw: str = None","text":"<p>The unparsed report string. Fetched on update()</p>"},{"location":"nbm/nbs/#service-avwxserviceservice","title":"service: avwx.service.Service","text":"<p>Service object used to fetch the report string</p>"},{"location":"nbm/nbs/#source-str-none","title":"source: str = None","text":"<p>Source URL root used to pull the current report data</p>"},{"location":"nbm/nbs/#station-avwxstation","title":"station: avwx.Station","text":"<p>Provides basic station info</p>"},{"location":"nbm/nbs/#units-avwxstructsunits","title":"units: avwx.structs.Units","text":"<p>Units inferred from the station location and report contents</p>"},{"location":"nbm/nbs/#updatetimeout-int-10-bool","title":"update(timeout: int = 10) -&gt; bool","text":"<p>Updates report data by fetching and parsing the report</p> <p>Returns <code>True</code> if a new report is available, else <code>False</code></p>"},{"location":"nbm/nbs/#class-avwxstructsnbsdata","title":"class avwx.structs.NbsData","text":"<p>forecast: List[avwx.structs.NbsPeriod]</p> <p>raw: str</p> <p>station: str</p> <p>time: avwx.structs.Timestamp</p>"},{"location":"nbm/nbs/#class-avwxstructsnbsperiod","title":"class avwx.structs.NbsPeriod","text":"<p>ceiling: avwx.structs.Number</p> <p>cloud_base: avwx.structs.Number</p> <p>dewpoint: avwx.structs.Number</p> <p>freezing_precip: avwx.structs.Number</p> <p>haines: List[avwx.structs.Number]</p> <p>icing_amount_6: avwx.structs.Number</p> <p>mixing_height: avwx.structs.Number</p> <p>precip_amount_12: avwx.structs.Number</p> <p>precip_amount_6: avwx.structs.Number</p> <p>precip_chance_12: avwx.structs.Number</p> <p>precip_chance_6: avwx.structs.Number</p> <p>precip_duration: avwx.structs.Number</p> <p>rain: avwx.structs.Number</p> <p>sky_cover: avwx.structs.Number</p> <p>sleet: avwx.structs.Number</p> <p>snow_amount_6: avwx.structs.Number</p> <p>snow_level: avwx.structs.Number</p> <p>snow: avwx.structs.Number</p> <p>solar_radiation: avwx.structs.Number</p> <p>temperature: avwx.structs.Number</p> <p>thunderstorm_12: avwx.structs.Number</p> <p>thunderstorm_3: avwx.structs.Number</p> <p>time: avwx.structs.Timestamp</p> <p>transport_wind_direction: avwx.structs.Number</p> <p>transport_wind_speed: avwx.structs.Number</p> <p>visibility: avwx.structs.Number</p> <p>wave_height: avwx.structs.Number</p> <p>wind_direction: avwx.structs.Number</p> <p>wind_gust: avwx.structs.Number</p> <p>wind_speed: avwx.structs.Number</p>"},{"location":"util/data/","title":"Data Updates","text":"<p>Certain components of AVWX rely on data files compiled from remote sources that should be kept up to date. This includes:</p> <ul> <li>Station information database</li> <li>Navigation aids</li> <li>Aircraft codes</li> </ul> <p>While these are updated on a regular basis with point updates, you may wish to update them on a more frequent basis. As of version 1.7 of the library, you can do this manually with the <code>data</code> module.</p> <pre><code>&gt;&gt;&gt; from avwx.data import update_all\n&gt;&gt;&gt; update_all()\nTrue\n</code></pre> <p>This updates all package data files and <code>avwx.station.meta.__STATIONS_UPDATED__</code> date. Due to how this data is managed, you should only run updates prior to starting your primary Python application. Doing so during an existing run may still use old data depending on the architecture of your program.</p>"},{"location":"util/data/#avwxdataupdate_all-bool","title":"avwx.data.update_all() -&gt; bool","text":"<p>Update all local data. Requires a reimport to guarentee update</p>"},{"location":"util/data/#avwxdataupdate_aircraft-bool","title":"avwx.data.update_aircraft() -&gt; bool","text":"<p>Builds the aircraft code dict</p>"},{"location":"util/data/#avwxdataupdate_navaids-bool","title":"avwx.data.update_navaids() -&gt; bool","text":"<p>Builds the navaid coordinate map</p>"},{"location":"util/data/#avwxdataupdate_stations-bool","title":"avwx.data.update_stations() -&gt; bool","text":"<p>Builds the station information database</p>"},{"location":"util/exceptions/","title":"Exceptions","text":""},{"location":"util/exceptions/#class-avwxexceptionsbadstation","title":"class avwx.exceptions.BadStation","text":"<p>Station does not exist</p>"},{"location":"util/exceptions/#class-avwxexceptionsinvalidrequest","title":"class avwx.exceptions.InvalidRequest","text":"<p>Unable to fetch data</p>"},{"location":"util/exceptions/#class-avwxexceptionssourceerror","title":"class avwx.exceptions.SourceError","text":"<p>Source servers returned an error code</p>"},{"location":"util/service/","title":"Report Source Services","text":"<p>AVWX fetches the raw weather reports from third-party services via REST API calls or file downloads. We use Service objects to handle the request and extraction for us.</p>"},{"location":"util/service/#basic-module-use","title":"Basic Module Use","text":"<p>METARs and TAFs are the most widely-supported report types, so an effort has been made to localize some of these services to a regional source. The <code>get_service</code> function was introduced to determine the best service for a given station.</p>"},{"location":"util/service/#avwxserviceget_servicestation-str-country-str-avwxserviceservice","title":"avwx.service.get_service(station: str, country: str) -&gt; avwx.service.Service","text":"<p>Returns the preferred scrape service for a given station</p> <pre><code># Fetch Australian reports\nstation = 'YWOL'\ncountry = 'AU' # can source from avwx.Station.country\n# Get the station's preferred service and initialize to fetch METARs\nservice = avwx.service.get_service(station, country)('metar')\n# service is now avwx.service.AUBOM init'd to fetch METARs\n# Fetch the current METAR\nreport = service.fetch(station)\n</code></pre> <p>Other report types require specific service classes which are detailed below.</p>"},{"location":"util/service/#base-service-class","title":"Base Service Class","text":"<p>Both web scrape and file-based services are based off of the Service class and should all return the final report string with the fetch method.</p>"},{"location":"util/service/#class-avwxserviceservicereport_type-str","title":"class avwx.service.Service(report_type: str)","text":"<p>Base Service class for fetching reports</p>"},{"location":"util/service/#fetchstation-str-timeout-int-10-str","title":"fetch(station: str, timeout: int = 10) -&gt; str","text":"<p>Fetches a report string from the service</p>"},{"location":"util/service/#async-async_fetchstation-str-timeout-int-10-str","title":"async async_fetch(station: str, timeout: int = 10) -&gt; str","text":"<p>Asynchronously fetch a report string from the service</p>"},{"location":"util/service/#web-scrape-services","title":"Web Scrape Services","text":"<p>These services request reports via HTML scraping or direct API requests. Requests are ephemeral and will call the selected service each time.</p>"},{"location":"util/service/#classservicescrapescrapeservicereport_type-str","title":"class.service.scrape.ScrapeService(report_type: str)","text":"<p>Service class for fetching reports via direct web requests</p> <p>Unless overwritten, this class accepts <code>\"metar\"</code> and <code>\"taf\"</code> as valid report types</p>"},{"location":"util/service/#class-avwxservicenoaareport_type-str","title":"class avwx.service.NOAA(report_type: str)","text":"<p>Requests data from NOAA</p>"},{"location":"util/service/#class-avwxservicenoaa_addsreport_type-str","title":"class avwx.service.NOAA_ADDS(report_type: str)","text":"<p>Requests data from NOAA ADDS</p> <p>This class accepts <code>\"metar\"</code>, <code>\"taf\"</code>, and <code>\"aircraftreport\"</code> as valid report types. It will also accept <code>lat</code> and <code>lon</code> as fetch parameters in addition to <code>station</code>.</p>"},{"location":"util/service/#avwxserviceamoreport_type-str","title":"avwx.service.AMO(report_type: str)","text":"<p>Requests data from AMO KMA for Korean stations</p>"},{"location":"util/service/#avwxservicemacreport_type-str","title":"avwx.service.MAC(report_type: str)","text":"<p>Requests data from Meteorologia Aeronautica Civil for Columbian stations</p>"},{"location":"util/service/#avwxserviceaubomreport_type-str","title":"avwx.service.AUBOM(report_type: str)","text":"<p>Requests data from the Australian Bureau of Meteorology</p>"},{"location":"util/service/#file-services","title":"File Services","text":"<p>These services are directed at FTP servers to find the most recent file associated with the search criteria. Files are stored in a temporary directory which is deleted when the program ends. Fetch requests will extract reports from the downloaded file until an update interval has been exceeded, at which point the service will check for a newer file. You can also have direct access to all downloaded reports.</p>"},{"location":"util/service/#avwxservicefilesfileservicereport_type","title":"avwx.service.files.FileService(report_type)","text":"<p>Service class for fetching reports via managed source files</p>"},{"location":"util/service/#all-liststr","title":"all: List[str]","text":""},{"location":"util/service/#is_outdated-bool","title":"is_outdated: bool","text":""},{"location":"util/service/#last_updated-optionaldatetimedatetime","title":"last_updated: Optional[datetime.datetime]","text":""},{"location":"util/service/#update_interval-datetimetimedelta-datetimetimedeltaminutes10","title":"update_interval: datetime.timedelta = datetime.timedelta(minutes=10)","text":""},{"location":"util/service/#async-updatewait-bool-false-timeout-int-10-bool","title":"async update(wait: bool = False, timeout: int = 10) -&gt; bool","text":"<p>Update the stored file and returns success</p> <p>If wait, this will block if the file is already being updated</p>"},{"location":"util/service/#fetchstation-str-wait-bool-true-timeout-int-10-force-bool-false-optionalstr","title":"fetch(station: str, wait: bool = True, timeout: int = 10, force: bool = False) -&gt; Optional[str]","text":"<p>Fetch a report string from the source file</p> <p>If wait, this will block if the file is already being updated</p> <p>Can force the service to fetch a new file</p>"},{"location":"util/service/#async-async_fetchstation-str-wait-bool-true-timeout-int-10-force-bool-false-optionalstr","title":"async async_fetch(station: str, wait: bool = True, timeout: int = 10, force: bool = False) -&gt; Optional[str]","text":"<p>Asynchronously fetch a report string from the source file</p> <p>If wait, this will block if the file is already being updated</p> <p>Can force the service to fetch a new file</p>"},{"location":"util/service/#avwxservicenoaa_nbmreport_type","title":"avwx.service.NOAA_NBM(report_type)","text":"<p>Requests forecast data from NOAA NBM FTP servers</p> <p>This class accepts <code>\"nbh\"</code>, <code>\"nbs\"</code>, and <code>\"nbe\"</code> as valid report types</p>"},{"location":"util/service/#avwxservicenoaa_gfsreport_type","title":"avwx.service.NOAA_GFS(report_type)","text":"<p>Requests forecast data from NOAA GFS FTP servers</p> <p>This class accepts <code>\"mav\"</code> and <code>\"mex\"</code> as valid report types</p>"},{"location":"util/service/#bulk-services","title":"Bulk Services","text":"<p>These services are specifically for returning multiple reports at a time. For example, we'd want to know all SIGMETs currently in circulation. The sources can be FTP, scraping, or any other method. There is no need for specific stations or updating files behind the scenes.</p> <p>The <code>fetch</code> and <code>async_fetch</code> methods are identical except they return <code>List[str]</code> instead.</p>"},{"location":"util/service/#avwxservicebulknoaa_bulkreport_type","title":"avwx.service.bulk.NOAA_Bulk(report_type)","text":"<p>Requests data from NOAA FTP file servers</p> <p>This class accepts <code>\"metar\"</code>, <code>\"taf\"</code>, <code>\"aircraftreport\"</code>, and <code>\"airsigmet\"</code> as valid report types.</p>"},{"location":"util/service/#avwxservicebulknoaa_intlreport_type","title":"avwx.service.bulk.NOAA_Intl(report_type)","text":"<p>Scrapes international reports from NOAA. Designed to accompany <code>NOAA_Bulk</code> for AIRMET / SIGMET fetch.</p> <p>Currently, this class only accepts <code>\"airsigmet\"</code> as a valid report type.</p>"},{"location":"util/service/#adding-a-new-service","title":"Adding a New Service","text":"<p>If the existing services are not supplying the report(s) you need, adding a new service is easy. First, you'll need to determine if your source can be scraped or you need to download a file.</p>"},{"location":"util/service/#scrapeservice","title":"ScrapeService","text":"<p>For web scraping sources, you'll need to do the following things:</p> <ul> <li>Add the base URL and method (if not <code>\"GET\"</code>)</li> <li>Implement the <code>ScrapeService._make_url</code> to return the source URL and query parameters</li> <li>Implement the <code>ScrapeService._extract</code> function to return just the report string (starting at the station ID) from the response</li> </ul> <p>Let's look at the MAC service as an example:</p> <pre><code>class MAC(ScrapeService):\n\"\"\"\nRequests data from Meteorologia Aeronautica Civil for Columbian stations\n\"\"\"\n\nurl = \"http://meteorologia.aerocivil.gov.co/expert_text_query/parse\"\nmethod = \"POST\"\n\ndef _make_url(self, station: str) -&gt; (str, dict):\n\"\"\"\n    Returns a formatted URL and parameters\n    \"\"\"\n    return self.url, {\"query\": f\"{self.rtype} {station}\"}\n\ndef _extract(self, raw: str, station: str) -&gt; str:\n\"\"\"\n    Extracts the reports message using string finding\n    \"\"\"\n    report = raw[raw.find(station.upper() + \" \") :]\n    report = report[: report.find(\" =\")]\n    return report\n</code></pre> <p>Our URL and query parameters are returned using <code>_make_url</code> so <code>fetch</code> knows how to request the report. The result of this query is given to <code>_extract</code> which returns the report or list of reports.</p> <p>Once your service is created, it can optionally be added to <code>avwx.service.scrape.PREFERRED</code> if the service covers all stations with a known ICAO prefix or <code>avwx.service.scrape.BY_COUNTRY</code> if the service covers all stations in a single country. This is how <code>avwx.service.get_service</code> determines the preferred service. For example, the MAC service is preferred over NOAA for all ICAOs starting with \"SK\" while AUBOM is better for all Australian stations.</p>"},{"location":"util/service/#fileservice","title":"FileService","text":"<p>For file-based sources, you'll need to do the following things:</p> <ul> <li>Add the base URL and valid report types</li> <li>Implement the <code>FileService._urls</code> to iterate through source URLs</li> <li>Implement the <code>FileService._extract</code> function to return just the report string (starting at the station ID) from the response</li> </ul> <p>Let's look at the NOAA_NBM service as an example:</p> <pre><code>class NOAA_NBM(FileService):\n\"\"\"\n    Requests forecast data from NOAA NBM FTP servers\n    \"\"\"\n\n    url = \"https://nomads.ncep.noaa.gov/pub/data/nccf/com/blend/prod/blend.{}/{}/text/blend_{}tx.t{}z\"\n    _valid_types = (\"nbh\", \"nbs\", \"nbe\")\n\n    @property\n    def _urls(self) -&gt; Iterator[str]:\n\"\"\"\n        Iterates through hourly updates no older than two days\n        \"\"\"\n        date = dt.datetime.now(tz=dt.timezone.utc)\n        cutoff = date - dt.timedelta(days=1)\n        while date &gt; cutoff:\n            timestamp = date.strftime(r\"%Y%m%d\")\n            hour = str(date.hour).zfill(2)\n            yield self.url.format(timestamp, hour, self.report_type, hour)\n            date -= dt.timedelta(hours=1)\n\n    def _extract(self, station: str, source: TextIO) -&gt; Optional[str]:\n\"\"\"\n        Returns report pulled from the saved file\n        \"\"\"\n        start = station + \"   \"\n        end = self.report_type.upper() + \" GUIDANCE\"\n        txt = source.read()\n        txt = txt[txt.find(start) :]\n        txt = txt[: txt.find(end, 30)]\n        lines = []\n        for line in txt.split(\"\\n\"):\n            if \"CLIMO\" not in line:\n                line = line.strip()\n            if not line:\n                break\n            lines.append(line)\n        return \"\\n\".join(lines) or None\n</code></pre> <p>In this example, we iterate through <code>_urls</code> looking for the most recent published file. URL iterators should always have a lower bound to stop iteration so the service can return a null response.</p> <p>Once the file is downloaded, the requested station and file-like object are passed to the <code>_extract</code> method to find and return the report from the file. This method will not be called if the file doesn't exist.</p>"},{"location":"util/static/","title":"Static Values","text":"<p>Contains static objects for internal and external use</p>"},{"location":"util/static/#glossary","title":"Glossary","text":"<p>AVWX includes a compiled glossary of common report abbreviations that are listed separate from any other parsing mechanism. This is provided just for you to assist in translating the original reports or any item left in the <code>other</code> element.</p>"},{"location":"util/static/#avwxstaticglossaryglobal-str-str","title":"avwx.static.glossary.GLOBAL: *{str: str}","text":"<p>Glossary of abreviations found in reports. These should be treated as default values. OTher elements may overwrite in specific instances.</p>"},{"location":"util/static/#avwxstaticglossarymetar-str-str","title":"avwx.static.glossary.METAR: *{str: str}","text":"<p>Glossary conflicts used only in METARs</p>"},{"location":"util/static/#avwxstaticglossaryna_regional-str-str","title":"avwx.static.glossary.NA_REGIONAL: *{str: str}","text":"<p>Glossary items and conflicts used for reports referencing locations in North America</p>"},{"location":"util/static/#station-identification","title":"Station Identification","text":"<p>METAR and TAF reports come in two variants depending on the station's location: North American &amp; International. This affects both element parsing and inferred units of measurement. AVWX determines this by looking at the station's ICAO value.</p>"},{"location":"util/static/#avwxstaticcorena_regions-str","title":"avwx.static.core.NA_REGIONS: [str]","text":"<p>Prefix indicating station uses North American formatting</p>"},{"location":"util/static/#avwxstaticcorein_regions-str","title":"avwx.static.core.IN_REGIONS: [str]","text":"<p>Prefix indicating station uses International formatting</p>"},{"location":"util/static/#avwxstaticcorem_na_regions-str","title":"avwx.static.core.M_NA_REGIONS: [str]","text":"<p>Two-character prefix indication Central American station uses North American formatting</p>"},{"location":"util/static/#avwxstaticcorem_in_regions-str","title":"avwx.static.core.M_IN_REGIONS: [str]","text":"<p>Two-character prefix indication Central American station uses International formatting</p>"},{"location":"util/static/#translations","title":"Translations","text":"<p>Static values used to translate report data</p>"},{"location":"util/static/#avwxstaticcorecloud_translations-str-str","title":"avwx.static.core.CLOUD_TRANSLATIONS: {str: str}","text":"<p>Dictionary associating cloud layer and cloud codes with descriptions</p>"},{"location":"util/static/#avwxstatictaficing_conditions-str-str","title":"avwx.static.taf.ICING_CONDITIONS: {str: str}","text":"<p>Dictionary associating icing report IDs with descriptions</p>"},{"location":"util/static/#avwxstatictafpressure_tendencies-str-str","title":"avwx.static.taf.PRESSURE_TENDENCIES: {str: str}","text":"<p>Dictionary associating pressure change IDs with descriptions</p>"},{"location":"util/static/#avwxstaticcoreremarks_elements-str-str","title":"avwx.static.core.REMARKS_ELEMENTS: {str: str}","text":"<p>Static remarks translation elements</p>"},{"location":"util/static/#avwxstaticcoreremarks_groups-str-str","title":"avwx.static.core.REMARKS_GROUPS: {str: str}","text":"<p>Static remarks translation group strings</p>"},{"location":"util/static/#avwxstatictafturbulence_conditions-str-str","title":"avwx.static.taf.TURBULENCE_CONDITIONS: {str: str}","text":"<p>Dictionary associating turbulence report IDs with descriptions</p>"},{"location":"util/static/#avwxstaticcorewx_translations-str-str","title":"avwx.static.core.WX_TRANSLATIONS: {str: str}","text":"<p>Dictionary associating WX codes with descriptions</p>"},{"location":"util/static/#units","title":"Units","text":"<p>Static values involving units of measure</p>"},{"location":"util/static/#avwxstaticcorecardinals-str-int","title":"avwx.static.core.CARDINALS: {str: int}","text":"<p>Dictionary of cardinal direction values</p>"},{"location":"util/static/#avwxstaticcorecloud_list-str","title":"avwx.static.core.CLOUD_LIST: [str]","text":"<p>List of cloud layer abbreviations</p>"},{"location":"util/static/#avwxstaticcoreflight_rules-str","title":"avwx.static.core.FLIGHT_RULES: [str]","text":"<p>List of flight rules abbreviations</p>"},{"location":"util/static/#avwxstaticcorefractions-str-str","title":"avwx.static.core.FRACTIONS: {str: str}","text":"<p>Dictionary associating fraction strings with their spoken version</p>"},{"location":"util/static/#avwxstaticcorein_units-str-str","title":"avwx.static.core.IN_UNITS: {str: str}","text":"<p>International variant units</p>"},{"location":"util/static/#avwxstaticcorena_units-str-str","title":"avwx.static.core.NA_UNITS: {str: str}","text":"<p>North American variant units</p>"},{"location":"util/static/#avwxstaticcorenumber_repl-str-str","title":"avwx.static.core.NUMBER_REPL: {str: str}","text":"<p>Dictionary associating algebraic signs with their spoken version</p>"},{"location":"util/static/#avwxstaticcorespecial_numbers-str-tuple","title":"avwx.static.core.SPECIAL_NUMBERS: {str: tuple}","text":"<p>Dictionary associating special number values with their spoken version</p>"},{"location":"util/static/#avwxstaticcorespoken_units-str-str","title":"avwx.static.core.SPOKEN_UNITS: {str: str}","text":"<p>Units required to be translated in order to be spoken properly</p>"},{"location":"util/station/","title":"Station","text":"<p>This module contains station/airport dataclasses and search functions.</p> <p>For the purposes of AVWX, a station is any physical location that has an ICAO or GPS identification code. These are usually airports, but smaller locations might not generate certain report types or defer to larger stations nearby. For example, small airports with an AWOS system might not send the report to NOAA or other local authority. They also include remote weather observation stations not associated with airports like weather buouys.</p>"},{"location":"util/station/#class-avwxstation","title":"class avwx.Station","text":"<p>The Station dataclass stores basic info about the desired station and available Runways.</p> <p>The easiest way to get a station is to supply the ICAO, IATA, or GPS code. The example below uses <code>from_code</code> which checks against all three types, but you can also use <code>from_icao</code>, <code>from_iata</code>, or <code>from_gps</code> if you know what type of code you are using. This can be important if you may be using a code used by more than one station depending on the context. ICAO and IATA codes are guarenteed unique, but not all airports have them. That said, all stations available in AVWX have either an ICAO or GPS code.</p> <pre><code>&gt;&gt;&gt; from avwx import Station\n&gt;&gt;&gt; klex = Station.from_code(\"KLEX\")\n&gt;&gt;&gt; f\"{klex.name} in {klex.city}, {klex.state}\"\n'Blue Grass Airport in Lexington, KY'\n&gt;&gt;&gt; coord = round(klex.latitude, 3), round(klex.longitude, 3)\n&gt;&gt;&gt; f\"Located at {coord} at {klex.elevation_ft} feet ({klex.elevation_m} meters)\"\n'Located at (38.036, -84.606) at 979 feet (298 meters)'\n&gt;&gt;&gt; rw = max(klex.runways, key=lambda r: r.length_ft)\n&gt;&gt;&gt; f\"Its longest runway is {rw.ident1}/{rw.ident2} at {rw.length_ft} feet\"\n'Its longest runway is 04/22 at 7003 feet'\n</code></pre> <p>This is also the same information you'd get from calling Report.station.</p> <pre><code>&gt;&gt;&gt; from avwx import Metar\n&gt;&gt;&gt; klex = Metar('KLEX')\n&gt;&gt;&gt; klex.station.name\n'Blue Grass Airport'\n</code></pre>"},{"location":"util/station/#city-str","title":"city: str","text":""},{"location":"util/station/#coord-avwxstructscoord","title":"coord: avwx.structs.Coord","text":""},{"location":"util/station/#country-str","title":"country: str","text":""},{"location":"util/station/#distancelat-float-lon-float-float-float","title":"distance(lat: float, lon: float) -&gt; (float, float):","text":"<p>Returns the distance in miles and kilometers from a given lat,lon</p>"},{"location":"util/station/#elevation_ft-int","title":"elevation_ft: int","text":"<p>Elevation in feet</p>"},{"location":"util/station/#elevation_m-int","title":"elevation_m: int","text":"<p>Elevation in meters</p>"},{"location":"util/station/#from_codeident-str-station","title":"from_code(ident: str) -&gt; Station","text":"<p>Load a Station from an ICAO, GPS, or IATA code in that order</p>"},{"location":"util/station/#from_gpsident-str-station","title":"from_gps(ident: str) -&gt; Station","text":"<p>Load a Station from a GPS code</p>"},{"location":"util/station/#from_icaoident-str-station","title":"from_icao(ident: str) -&gt; Station","text":"<p>Load a Station from an ICAO station ident</p>"},{"location":"util/station/#from_iataident-str-station","title":"from_iata(ident: str) -&gt; Station","text":"<p>Load a Station from an IATA code</p>"},{"location":"util/station/#gps-optionalstr","title":"gps: Optional[str]","text":"<p>Station's code for GPS navigation</p>"},{"location":"util/station/#iata-optionalstr","title":"iata: Optional[str]","text":"<p>Station's 3-char IATA ident</p>"},{"location":"util/station/#icao-optionalstr","title":"icao: Optional[str]","text":"<p>Station's 4-char ICAO ident</p>"},{"location":"util/station/#latitude-float","title":"latitude: float","text":""},{"location":"util/station/#local-optionalstr","title":"local: Optional[str]*","text":"<p>Station's code assigned by its local authority</p>"},{"location":"util/station/#longitude-float","title":"longitude: float","text":""},{"location":"util/station/#lookup_code-str","title":"lookup_code: str","text":"<p>Returns the ICAO or GPS code for report fetch</p>"},{"location":"util/station/#name-str","title":"name: str","text":"<p>Station / airport name</p>"},{"location":"util/station/#nearbyis_airport-bool-false-sends_reports-bool-true-max_coord_distance-float-10-t-dict","title":"nearby(is_airport: bool = False, sends_reports: bool = True, max_coord_distance: float = 10) -&gt; [(T, dict)]:","text":"<p>Returns Stations nearest to current station and their distances</p> <p>NOTE: Becomes less accurate toward poles and doesn't cross +/-180</p>"},{"location":"util/station/#nearestlat-float-none-lon-float-none-is_airport-bool-false-sends_reports-bool-true-max_distance-float-50-avwxstation-dict","title":"nearest(lat: float = None, lon: float = None, is_airport: bool = False, sends_reports: bool = True max_distance: float = 50) -&gt; (avwx.Station, dict)","text":"<p>Load the Station nearest to your location or a lat,lon coordinate pair</p> <p>Returns the Station and distances from source</p> <p>NOTE: Becomes less accurate toward poles and doesn't cross +/-180</p>"},{"location":"util/station/#note-str","title":"note: str","text":"<p>Location notes like nearby landmarks</p>"},{"location":"util/station/#runways-avwxstationrunway","title":"runways: [avwx.station.Runway]","text":"<p>List of available Runway objects sorted longest to shortest</p>"},{"location":"util/station/#sends_reports-bool","title":"sends_reports: bool","text":"<p>Returns whether or not a Station likely sends weather reports</p>"},{"location":"util/station/#state-str","title":"state: str","text":""},{"location":"util/station/#type-str","title":"type: str","text":"<p>Station / airport type like <code>\"large_airport\"</code></p>"},{"location":"util/station/#website-str","title":"website: str","text":"<p>Station / airport primary website</p>"},{"location":"util/station/#wiki-str","title":"wiki: str","text":"<p>Station Wikipedia page</p>"},{"location":"util/station/#class-avwxstationrunway","title":"class avwx.station.Runway","text":"<p>Represents a runway at an airport</p>"},{"location":"util/station/#length_ft-int","title":"length_ft: int","text":"<p>Runway length in feet</p>"},{"location":"util/station/#width_ft-int","title":"width_ft: int","text":"<p>Runway width in feet</p>"},{"location":"util/station/#ident1-str","title":"ident1: str","text":"<p>Runway number 01-18 with modifiers. Ex: <code>\"17L\"</code></p>"},{"location":"util/station/#ident2-str","title":"ident2: str","text":"<p>Runway number 19-36 with modifiers. Ex: <code>\"35R\"</code></p>"},{"location":"util/station/#avwxstationstation_listreporting-bool-true-str","title":"avwx.station.station_list(reporting: bool = True) -&gt; [str]:","text":"<p>Returns a list of station idents matching the search criteria</p>"},{"location":"util/station/#avwxstationnearestlat-float-lon-float-n-int-1-is_airport-bool-false-sends_reports-bool-true-max_distance-float-10-dict","title":"avwx.station.nearest(lat: float, lon: float, n: int = 1, is_airport: bool = False, sends_reports: bool = True, max_distance: float = 10) -&gt; [dict]","text":"<p>Finds the nearest n Stations to a lat,lon coordinate pair</p> <p>Returns the Station and coordinate distance from source</p> <p>NOTE: Becomes less accurate toward poles and doesn't cross +/-180</p>"},{"location":"util/structs/","title":"Other Data Structures","text":""},{"location":"util/structs/#class-avwxstructsaircraft","title":"class avwx.structs.Aircraft","text":"<p>from_icao(code: str) -&gt; avwx.structs.Aircraft</p> <p>Load an Aircraft from an ICAO aircraft code</p> <p>code: str</p> <p>type: str</p>"},{"location":"util/structs/#class-avwxstructsbulletin","title":"class avwx.structs.Bulletin","text":"<p>country: str</p> <p>number: int</p> <p>repr: str</p> <p>type: avwx.structs.Code</p>"},{"location":"util/structs/#class-avwxstructscloud","title":"class avwx.structs.Cloud","text":"<p>base: int = None</p> <p>modifier: str = None</p> <p>repr: str</p> <p>top: int = None</p> <p>type: str = str</p>"},{"location":"util/structs/#class-avwxstructscode","title":"class avwx.structs.Code","text":"<p>from_dict(key: Optional[str], codes: Dict[str, str], default: str = None, error: bool = True) -&gt; avwx.structs.Code</p> <p>Load a code from a known key and value dict</p> <p>repr: str</p> <p>value: str</p>"},{"location":"util/structs/#class-avwxstructscoord","title":"class avwx.structs.Coord","text":"<p>lat: float</p> <p>lon: float</p> <p>repr: str = None</p> <p>pair: Tuple[float, float]</p> <p>point: shapely.geometry.Point</p> <p>to_dms(value: float) -&gt; Tuple[int, int, int]</p> <p>Convert a coordinate decimal value to degree, minute, second</p>"},{"location":"util/structs/#class-avwxstructsfraction","title":"class avwx.structs.Fraction","text":"<p>denominator: int</p> <p>normalized: str</p> <p>numerator: int</p>"},{"location":"util/structs/#class-avwxstructsicing","title":"class avwx.structs.Icing","text":"<p>ceiling: avwx.structs.Number = None</p> <p>floor: avwx.structs.Number = None</p> <p>severity: str</p> <p>type: str = None</p>"},{"location":"util/structs/#class-avwxstructslocation","title":"class avwx.structs.Location","text":"<p>direction: avwx.structs.Number</p> <p>distance: avwx.structs.Number</p> <p>repr: str</p> <p>station: str</p>"},{"location":"util/structs/#class-avwxstructsmovement","title":"class avwx.structs.Movement","text":"<p>direction: Optional[avwx.structs.Number]</p> <p>repr: str</p> <p>speed: Optional[avwx.structs.Number]</p>"},{"location":"util/structs/#class-avwxstructsnumber","title":"class avwx.structs.Number","text":"<p>repr: str</p> <p>spoken: str</p> <p>value: float</p>"},{"location":"util/structs/#class-avwxstructspressuretendency","title":"class avwx.structs.PressureTendency","text":"<p>repr: str</p> <p>tendency: str</p> <p>change: float</p>"},{"location":"util/structs/#class-avwxstructsremarksdata","title":"class avwx.structs.RemarksData","text":"<p>codes: List[avwx.structs.Code] = []</p> <p>dewpoint_decimal: avwx.structs.Number = None</p> <p>maximum_temperature_24: avwx.structs.Number = None</p> <p>maximum_temperature_6: avwx.structs.Number = None</p> <p>minimum_temperature_24: avwx.structs.Number = None</p> <p>minimum_temperature_6: avwx.structs.Number = None</p> <p>precip_24_hours: avwx.structs.Number = None</p> <p>precip_36_hours: avwx.structs.Number = None</p> <p>precip_hourly: avwx.structs.Number = None</p> <p>pressure_tendency: avwx.structs.PressureTendency = None</p> <p>sea_level_pressure: avwx.structs.Number = None</p> <p>snow_depth: avwx.structs.Number = None</p> <p>sunshine_minutes: avwx.structs.Number = None</p> <p>temperature_decimal: avwx.structs.Number = None</p>"},{"location":"util/structs/#class-avwxstructsrunwayvisibility","title":"class avwx.structs.RunwayVisibility","text":"<p>repr: str</p> <p>runway: str</p> <p>trend: Optional[avwx.structs.Code]</p> <p>variable_visibility: List[avwx.structs.Number]</p> <p>visibility: Optional[avwx.structs.Number]</p>"},{"location":"util/structs/#class-avwxstructstimestamp","title":"class avwx.structs.Timestamp","text":"<p>dt: datetime.datetime</p> <p>repr: str</p>"},{"location":"util/structs/#class-avwxstructsturbulence","title":"class avwx.structs.Turbulence","text":"<p>ceiling: avwx.structs.Number = None</p> <p>floor: avwx.structs.Number = None</p> <p>severity: str</p>"},{"location":"util/structs/#class-avwxstructsunits","title":"class avwx.structs.Units","text":"<p>accumulation: str</p> <p>altimeter: str</p> <p>altitude: str</p> <p>temperature: str</p> <p>visibility: str</p> <p>wind_speed: str</p>"},{"location":"util/structs/#class-avwxstructsnbmunits","title":"class avwx.structs.NbmUnits","text":"<p>accumulation: str</p> <p>altimeter: str</p> <p>altitude: str</p> <p>duration: str</p> <p>solar_radiation: str</p> <p>temperature: str</p> <p>visibility: str</p> <p>wave_height: str</p> <p>wind_speed: str</p>"}]}